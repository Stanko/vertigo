{"version":3,"sources":["src/constants.ts","src/helpers.ts","src/convert-image-to-dots.ts","src/vertigo.ts","src/convert-image-to-spiral.ts","src/spiral.ts","src/demo-helpers.ts","src/demo.ts"],"names":[],"mappings":"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","file":"demo.480737d4.js","sourceRoot":"..","sourcesContent":["// -- Global\n\nexport const DEBUG = false;\n\nexport const MAXIMUM_BRIGHTNESS = 255;\n\nexport interface IDot {\n  x: number;\n  y: number;\n}\n\n// -- Dots\n\n// How many dots are added with each concentric circle\nexport const DOT_INCREMENT_STEP:number = 6;\n\nexport interface IDotsOptions {\n  resolution: number;\n  minimumDotRadius: number;\n  maximumDotRadius: number;\n  distanceBetweenDots: number;\n};\n\nexport interface IDotsOptionsPartial {\n  resolution?: number;\n  minimumDotRadius?: number;\n  maximumDotRadius?: number;\n  distanceBetweenDots?: number;\n};\n\nexport const dotsDefaultOptions:IDotsOptions = {\n  // Number of concentric circles\n  resolution: 25,\n  // Minimum dot radius\n  minimumDotRadius: 1,\n  // Maximum dot radius\n  maximumDotRadius: 5,\n  // Distance between dots\n  distanceBetweenDots: 2,\n};\n\nexport type TDotsImage = number[][];\n\n// -- Spiral\n\nexport interface ISpiralOptions {\n  minimumLineWidth: number;\n  maximumLineWidth: number;\n  distanceBetweenLines: number;\n  startingRadius: number;\n};\n\nexport interface ISpiralOptionsPartial {\n  minimumLineWidth?: number;\n  maximumLineWidth?: number;\n  distanceBetweenLines?: number;\n  startingRadius?: number;\n};\n\nexport const spiralDefaultOptions:ISpiralOptions = {\n  // Minimum line width\n  minimumLineWidth: 1,\n  // Maximum line width\n  maximumLineWidth: 5,\n  // Distance between lines\n  distanceBetweenLines: 1,\n  // Starting radius\n  startingRadius: 4,\n};\n\n\n\nexport interface ISpiralSegment {\n  x: number;\n  y: number;\n  width: number;\n};\n\nexport type TSpiralImage = ISpiralSegment[];\n","export function toFixed(number:number, numberOfDecimalSpaces:number = 2):number {\n  return parseFloat(number.toFixed(numberOfDecimalSpaces));\n}\n\n\nexport function getRectBrightness(ctx:CanvasRenderingContext2D, x:number, y:number, rectWidth:number):number {\n  const imageData = ctx.getImageData(x, y, rectWidth, rectWidth);\n\n  let brightness = 0;\n\n  for (let k = 0; k < imageData.data.length; k += 4) {\n      const r = imageData.data[k];\n      const g = imageData.data[k + 1];\n      const b = imageData.data[k + 2];\n      const a = imageData.data[k + 3];\n\n      brightness += 0.299 * r + 0.587 * g + 0.114 * b;\n  }\n\n  const COLORS_COUNT = 4; // r g b a\n\n  return brightness / (imageData.data.length / COLORS_COUNT);\n}\n\nexport function createSvg(svgSize:number, moveToCenter:boolean, className:string):SVGElement {\n  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n  const min = moveToCenter ? svgSize / -2 : 0;\n\n  svg.setAttribute('class', className);\n  svg.setAttribute('viewBox', `${ min } ${ min } ${ svgSize } ${ svgSize }`);\n\n  return svg;\n}\n\n\nexport function mapRange(value:number, inputRange:number, outputMin:number, outputMax:number) {\n  const outputRange = outputMax - outputMin;\n  return value / inputRange * outputRange + outputMin;\n}\n\nexport function drawImageOnCanvas(\n  imageSrc:string,\n  size: 500,\n  callback:(canvas:HTMLCanvasElement) => void,\n) {\n  const canvas:HTMLCanvasElement = document.createElement('canvas');\n  canvas.width = size;\n  canvas.height = size;\n\n  const ctx:CanvasRenderingContext2D = canvas.getContext('2d');\n\n  const image = new Image();\n  image.addEventListener('load', () => {\n    // Get the largest square from the image\n    let yOffset = 0;\n    let xOffset = 0;\n    let imageSize;\n\n    if (image.height > image.width) {\n      yOffset = (image.height - image.width) / 2;\n      imageSize = image.width;\n    } else {\n      xOffset = (image.width - image.height) / 2;\n      imageSize = image.height;\n    }\n\n    ctx.drawImage(image, xOffset, yOffset, imageSize, imageSize, 0, 0, size, size);\n\n    callback(canvas);\n  });\n\n  // Load image\n  image.src = imageSrc;\n}\n","import {\n  drawImageOnCanvas,\n  getRectBrightness,\n  mapRange,\n  toFixed,\n} from './helpers';\nimport {\n  DEBUG,\n  DOT_INCREMENT_STEP,\n  dotsDefaultOptions,\n  IDotsOptions,\n  IDotsOptionsPartial,\n  MAXIMUM_BRIGHTNESS,\n  TDotsImage,\n} from './constants';\n\n\nfunction getDotSizeFromRect(brightness, minimumDotRadius, maximumDotRadius) {\n  const circleSize = mapRange(brightness, MAXIMUM_BRIGHTNESS, minimumDotRadius, maximumDotRadius);\n\n  return toFixed(circleSize, 2);\n}\n\nfunction getRectCornerFromCenter(r, angle, rectangleSize, size) {\n  const rectCenterX = r * Math.cos(angle);\n  const rectCenterY = r * Math.sin(angle);\n\n  const x = rectCenterX - (rectangleSize / 2) + (size / 2);\n  const y = rectCenterY - (rectangleSize / 2) + (size / 2);\n\n  return {\n    x,\n    y,\n  };\n}\n\n// TODO low res\n// if (brightness < 100) {\n//   convertedImage[i][j] = 1;\n// } else if (brightness < 200) {\n//   convertedImage[i][j] = 2;\n// } else {\n//   convertedImage[i][j] = 4;\n// }\n\nexport default function convertImageToDots(\n  imageSrc:string,\n  customOptions:IDotsOptionsPartial,\n  callback:(convertedImage:TDotsImage) => void\n) {\n  const size = 500;\n\n  const options:IDotsOptions = {\n    ...dotsDefaultOptions,\n    ...customOptions,\n  };\n\n  drawImageOnCanvas(imageSrc, size, (canvas) => {\n    const ctx:CanvasRenderingContext2D = canvas.getContext('2d');\n\n    const convertedImage:TDotsImage = [[]];\n    const rectangleSize = size / 2 / (options.resolution + 0.5);\n\n    const helperRectangles = [];\n\n    // Center dot\n    const { x, y } = getRectCornerFromCenter(0, 0, rectangleSize, size);\n    const brightness = getRectBrightness(ctx, x, y, rectangleSize);\n\n    convertedImage[0][0] = getDotSizeFromRect(brightness, options.minimumDotRadius, options.maximumDotRadius);\n\n    if (DEBUG) {\n      helperRectangles.push({ x, y })\n    }\n\n    for (let i = 1; i <= options.resolution; i++) {\n      const r = i * rectangleSize;\n\n      const dotCount = i * DOT_INCREMENT_STEP;\n      const dotAngleStep = 360 / dotCount;\n\n      convertedImage[i] = [];\n\n      for (let j = 0; j < dotCount; j++) {\n        const angle = Math.PI * (dotAngleStep * j) / 180;\n\n        const { x, y } = getRectCornerFromCenter(r, angle, rectangleSize, size);\n\n        const brightness = getRectBrightness(ctx, x, y, rectangleSize);\n\n        convertedImage[i][j] = getDotSizeFromRect(brightness, options.minimumDotRadius, options.maximumDotRadius);\n\n        if (DEBUG) {\n          helperRectangles.push({ x, y });\n        }\n      }\n    }\n\n    callback(convertedImage);\n\n    if (DEBUG) {\n      ctx.strokeStyle = 'orange';\n\n      helperRectangles.forEach(rect => {\n        ctx.strokeRect(rect.x, rect.y, rectangleSize, rectangleSize);\n      });\n\n      document.querySelector('body').appendChild(canvas);\n    }\n  });\n}\n","import {\n  DOT_INCREMENT_STEP,\n  IDotsOptions,\n  IDotsOptionsPartial,\n  dotsDefaultOptions,\n  TDotsImage,\n} from './constants';\n\nimport { createSvg } from './helpers';\nimport convertImageToDots from './convert-image-to-dots';\n\n// TODO\n//\n// * Dynamic dot size\n// * Performance?\n\ninterface IDot {\n  element: SVGCircleElement;\n  x: string;\n  y: string;\n  scale: number;\n};\n\ntype TConvertCallback = (convertedImage:TDotsImage) => void;\n\nexport default class Vertigo {\n  private options:IDotsOptions;\n  private dots:IDot[][];\n  private radiusGrowStep:number;\n  private imageURL:string;\n\n  public svg:SVGElement;\n\n  constructor(options?:IDotsOptionsPartial) {\n    this.options = {\n      ...dotsDefaultOptions,\n      ...options,\n    };\n\n    this.radiusGrowStep = this.options.maximumDotRadius * 2 + this.options.distanceBetweenDots;\n\n    const size = this.options.resolution * 2 * this.radiusGrowStep;\n    const svgSize = size + this.options.maximumDotRadius * 2;\n\n    this.svg = createSvg(svgSize, true, 'Vertigo');\n\n    this.generateDots();\n  }\n\n  private static createDot(x:string, y:string, dotRadius:number, className = 'Dots-dot'):IDot {\n    const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n    dot.setAttribute('class', className);\n    dot.setAttribute('cx', x);\n    dot.setAttribute('cy', y);\n    dot.setAttribute('r', dotRadius.toString());\n\n    return {\n      element: dot,\n      x,\n      y,\n      scale: 1,\n    };\n  }\n\n  private generateDots() {\n    // Create central dot\n    const centralDot = Vertigo.createDot('0', '0', this.options.minimumDotRadius);\n\n    this.dots = [\n      [centralDot],\n    ];\n\n    this.svg.appendChild(centralDot.element);\n\n    for (let i = 1; i <= this.options.resolution; i++) {\n      const r = i * this.radiusGrowStep;\n\n      const dotCount = i * DOT_INCREMENT_STEP;\n      const dotAngleStep = 360 / dotCount;\n\n      this.dots[i] = [];\n\n      for (let j = 0; j < dotCount; j++) {\n        const angle = Math.PI * (dotAngleStep * j) / 180;\n\n        const x = (r * Math.cos(angle)).toFixed(3);\n        const y = (r * Math.sin(angle)).toFixed(3);\n\n        const dot = Vertigo.createDot(x, y, this.options.minimumDotRadius);\n\n        this.dots[i].push(dot);\n\n        this.svg.appendChild(dot.element);\n      }\n    }\n  }\n\n  public drawImage(image:TDotsImage) {\n    image.forEach((dots:number[], i:number) => {\n      dots.forEach((dotScale:number, j:number) => {\n        const circle = this.dots[i];\n\n        if (circle) {\n          const dot = circle[j];\n\n          if (dot.scale !== dotScale) {\n            dot.scale = dotScale;\n\n            dot.element.setAttribute('r', dotScale.toString());\n          }\n        }\n      });\n    });\n  }\n\n  public convertImage(imageURL, callback?:TConvertCallback) {\n    convertImageToDots(imageURL, this.options, (convertedImage:TDotsImage) => {\n      this.drawImage(convertedImage);\n      this.imageURL = imageURL;\n\n      if (callback) {\n        callback(convertedImage);\n      }\n    });\n  }\n\n  private removeDots() {\n    this.dots.forEach(circle => {\n      circle.forEach(dot => {\n        dot.element.parentNode.removeChild(dot.element);\n      });\n    });\n  }\n\n  public setOptions(newOptions:IDotsOptionsPartial, callback?:TConvertCallback) {\n    this.options = {\n      ...this.options,\n      ...newOptions,\n    };\n\n    this.radiusGrowStep = this.options.maximumDotRadius * 2 + this.options.distanceBetweenDots;\n\n    const size = this.options.resolution * 2 * this.radiusGrowStep;\n    const svgSize = size + this.options.maximumDotRadius * 2;\n\n    // Update svg size\n    this.svg.setAttribute('viewBox', `${ svgSize / -2 } ${ svgSize / -2 } ${ svgSize } ${ svgSize }`);\n\n    this.removeDots();\n    this.generateDots();\n\n    if (this.imageURL) {\n      this.convertImage(this.imageURL, callback);\n    }\n  }\n}\n","import {\n  drawImageOnCanvas,\n  getRectBrightness,\n  mapRange,\n  toFixed,\n} from './helpers';\nimport {\n  DEBUG,\n  ISpiralOptions,\n  ISpiralOptionsPartial,\n  MAXIMUM_BRIGHTNESS,\n  spiralDefaultOptions,\n  TSpiralImage,\n} from './constants';\n\n\nexport default function convertImageToSpiral(\n  imageSrc:string,\n  customOptions:ISpiralOptionsPartial,\n  callback:(convertedImage:TSpiralImage) => void\n) {\n  const size = 500;\n\n  const options:ISpiralOptions = {\n    ...spiralDefaultOptions,\n    ...customOptions,\n  };\n\n  drawImageOnCanvas(imageSrc, size, (canvas) => {\n    const ctx:CanvasRenderingContext2D = canvas.getContext('2d');\n    const helperRectangles = [];\n    const convertedImage:TSpiralImage = [];\n\n    const center = size / 2;\n\n    // Experiment with the size of the rectangle\n    const rectangleSize = Math.round((options.distanceBetweenLines + options.maximumLineWidth) * 0.8);\n\n    const distance = (options.distanceBetweenLines + options.maximumLineWidth) / (2 * Math.PI);\n\n    // Size of the image, minus the width of the starting circle\n    // divided by the distance between lines\n    const maxHalfRotationsCount = Math.floor((size - (options.startingRadius * 2)) / (options.distanceBetweenLines + options.maximumLineWidth));\n\n    // Maximum spiral angle\n    const maxAngle = maxHalfRotationsCount * Math.PI; // size / 2.1 / distance; // In radians\n\n    let angleIncrementStep = 3 / options.startingRadius;\n\n    for (let angle = 0; angle < maxAngle; angle += angleIncrementStep) {\n      const r = options.startingRadius + distance * angle;\n      const x = toFixed(center + r * Math.cos(angle), 3);\n      const y = toFixed(center + r * Math.sin(angle), 3);\n\n      helperRectangles.push({ x, y });\n\n      const brightness = getRectBrightness(ctx, x, y, rectangleSize);\n      const width = mapRange(brightness, MAXIMUM_BRIGHTNESS, options.minimumLineWidth, options.maximumLineWidth);\n\n      angleIncrementStep = 3 / r;\n\n      convertedImage.push({\n        x,\n        y,\n        width,\n      });\n    }\n\n    callback(convertedImage);\n\n    if (DEBUG) {\n      ctx.strokeStyle = 'orange';\n\n      helperRectangles.forEach(rect => {\n        ctx.strokeRect(rect.x, rect.y, rectangleSize, rectangleSize);\n      });\n\n      document.querySelector('body').appendChild(canvas);\n    }\n  });\n}\n\n\n\n\n\n\n","import {\n  IDot,\n  ISpiralOptions,\n  ISpiralOptionsPartial,\n  spiralDefaultOptions,\n  TSpiralImage,\n} from \"./constants\";\nimport {\n  createSvg,\n  toFixed,\n} from './helpers';\n\nimport convertImageToSpiral from './convert-image-to-spiral'\n\ntype TSpiralConvertCallback = (convertedImage: TSpiralImage) => void;\n\n\nlet prevAngle = null;\nlet reverse = false;\n\nconst SVG_SIZE = 500;\n\nexport default class VertigoSpiral {\n  private options: ISpiralOptions;\n  private imageURL: string;\n  private svgPath: SVGPathElement;\n\n  public svg: SVGElement;\n\n  constructor(options?: ISpiralOptionsPartial) {\n    this.options = {\n      ...spiralDefaultOptions,\n      ...options,\n    };\n\n    this.svg = createSvg(SVG_SIZE, false, 'Spiral');\n\n    this.svgPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n    this.svgPath.setAttribute('class', 'Spiral-path');\n\n    this.svg.appendChild(this.svgPath);\n  }\n\n  public convertImage(imageURL, callback?: TSpiralConvertCallback) {\n    convertImageToSpiral(imageURL, this.options, (convertedImage: TSpiralImage) => {\n      this.drawImage(convertedImage);\n      this.imageURL = imageURL;\n\n      if (callback) {\n        callback(convertedImage);\n      }\n    });\n  }\n\n  // Takes three dots and returns two dots,\n  // a vector which direction is half angle between these three dots\n  // and velocity is equal to a spiral line's width at that dot\n  /*\n                          • outerDots[0]\n                         /\n                        /\n    previousDot •------• dot\n                      / \\\n                     /   • nextDot\n       outerDots[1] •\n  */\n  private static getOuterDots(previousDot, dot, nextDot) {\n    // Angle between (previosDot, dot) vector and x axis\n    /*\n    previousDot •------• dot\n               angle1 / \\\n                     /   • nextDot\n    */\n    let angle1 = VertigoSpiral.getAngleBetweenThreeDots(previousDot, dot, nextDot) / 2;\n\n    // Angle between (previosDot, dot) vector and x axis\n    /*\n                 dot •--------• (dot.x + 100, dot.y)\n                    / angle2\n                   /\n      previousDot •\n    */\n    const angle2 = VertigoSpiral.getAngleBetweenThreeDots(previousDot, dot, {\n      x: dot.x + 100, // Moving dot on x axis\n      y: dot.y,\n    });\n\n    // Angle between the x axis and the half angle vector\n    const angle = toFixed(angle2 - angle1, 2);\n\n    const halfWidth = dot.width / 2;\n\n    const point1 = {\n      x: toFixed(dot.x + halfWidth * Math.cos(angle), 2),\n      y: toFixed(dot.y - halfWidth * Math.sin(angle), 2),\n    };\n\n    const point2 = {\n      x: toFixed(dot.x + halfWidth * Math.cos(angle + Math.PI), 2),\n      y: toFixed(dot.y - halfWidth * Math.sin(angle + Math.PI), 2),\n    };\n\n    const outerDots = [\n      point1,\n      point2,\n    ];\n\n    if (prevAngle === null) {\n      prevAngle = angle;\n    }\n    if (angle > Math.PI && prevAngle < Math.PI) {\n      reverse = !reverse;\n    }\n\n    prevAngle = angle;\n\n    // When angle is PI or 2*PI dots get inverted\n    if (reverse) {\n      return outerDots.reverse();\n    }\n\n    return outerDots;\n  }\n\n  private static getVector(a, b) {\n    return {\n      x: (a.x - b.x),\n      y: (a.y - b.y),\n    };\n  }\n\n  private static getAngleBetweenThreeDots(a, b, c) {\n    const vectorBA = VertigoSpiral.getVector(b, a);\n    const vectorBC = VertigoSpiral.getVector(b, c);\n\n    const angle = Math.atan2(vectorBC.y, vectorBC.x) - Math.atan2(vectorBA.y, vectorBA.x);\n\n    return angle;\n  }\n\n  private static getBezier(end, c1, c2) {\n    return ` C ${ c1.x } ${ c1.y }, ${ c2.x } ${ c2.y }, ${ end.x } ${ end.y }`;\n\n    // Code for drawing a bezier on canvas\n    // leaving it here if I ever need it again\n    // It needs a start point, which is the end point of the previous segment\n    // and in SVG case is automatically reused)\n    // ctx.moveTo(start.x, start.y);\n    // ctx.bezierCurveTo(c1.x, c1.y, c2.x, c2.y, end.x, end.y);\n  }\n\n  public drawImage(image) {\n    // Setting starting dot, based on \"startingRadius\"\n    // Spiral always starts from PI angle, that's why it's moved to the \"right\"\n    // (in other words, adding \"r\" to the \"x\" axis coordinate)\n    // while keeping y coordinate centered\n    const startingDot = `M ${ SVG_SIZE / 2 + this.options.startingRadius } ${ SVG_SIZE / 2 }`;\n    const pathOuter = [startingDot];\n    const pathInner = [startingDot];\n\n    const outerDots:IDot[][] = [];\n\n    // We need three dots to draw a bezier,\n    // that's why loop starts from 1 and ends on length - 1\n    for (let i = 1; i < image.length - 1; i++) {\n      const previousDot = image[i - 1];\n      const currentDot = image[i];\n      const nextDot = image[i + 1];\n\n      const od = VertigoSpiral.getOuterDots(previousDot, currentDot, nextDot);\n\n      const vector = VertigoSpiral.getVector(currentDot, nextDot);\n\n      const halfVector = {\n        x: toFixed(vector.x / 2, 2),\n        y: toFixed(vector.y / 2, 2),\n      };\n\n      outerDots.push([\n        ...od,\n        halfVector,\n      ]);\n    }\n\n    outerDots.forEach((outerDot, index) => {\n      const next = outerDots[index + 1];\n\n      if (next) {\n        const c11 = {\n          x: outerDot[0].x - outerDot[2].x,\n          y: outerDot[0].y - outerDot[2].y,\n        };\n        const c12 = {\n          x: next[0].x + outerDot[2].x,\n          y: next[0].y + outerDot[2].y,\n        };\n\n        pathOuter.push(VertigoSpiral.getBezier(\n          next[0],\n          c11,\n          c12,\n        ));\n\n        const c21 = {\n          x: outerDot[1].x - outerDot[2].x,\n          y: outerDot[1].y - outerDot[2].y,\n        };\n        const c22 = {\n          x: next[1].x + outerDot[2].x,\n          y: next[1].y + outerDot[2].y,\n        };\n\n        pathInner.push(VertigoSpiral.getBezier(\n          outerDot[1],\n          c22,\n          c21,\n        ));\n      }\n    });\n\n\n    this.svgPath.setAttribute('d', pathOuter.join('') + pathInner.reverse().join('') + ' Z');\n  }\n\n  public setOptions(newOptions:ISpiralOptionsPartial, callback?:TSpiralConvertCallback) {\n    this.options = {\n      ...this.options,\n      ...newOptions,\n    };\n\n    if (this.imageURL) {\n      this.convertImage(this.imageURL, callback);\n    }\n  }\n}\n","export function createOption({\n  callback,\n  label,\n  max,\n  min,\n  name,\n  step = '1',\n  value,\n}) {\n  const spanRange = document.createElement('span');\n  spanRange.innerHTML = `(${ min } - ${ max })`;\n\n  const labelName = document.createElement('label');\n  labelName.innerHTML = `${ label }: `;\n  labelName.appendChild(spanRange);\n\n  const spanValue = document.createElement('span');\n  spanValue.innerHTML = value;\n\n  const input = document.createElement('input');\n  input.setAttribute('type', 'range');\n  input.setAttribute('min', min);\n  input.setAttribute('max', max);\n  input.setAttribute('value', value);\n  input.setAttribute('step', step);\n  input.setAttribute('class', `OptionsInput OptionsInput--${ name }`);\n  input.addEventListener('change', e => {\n    callback(name, e.target.value);\n    spanValue.innerHTML = e.target.value;\n  });\n\n  const divOption = document.createElement('div');\n  divOption.appendChild(labelName);\n  divOption.appendChild(input);\n  divOption.appendChild(spanValue);\n\n  return divOption;\n}\n","import Vertigo from './vertigo';\nimport VertigoSpiral from './spiral';\nimport {\n  ISpiralOptions,\n  IDotsOptions,\n} from './constants';\nimport { createOption } from './demo-helpers';\n\n\nconst helloImage:HTMLElement = document.querySelector('.TestImage--hello');\n\n// ------- DOTS\n\nconst dotsSvgWrapperInner:HTMLElement = document.querySelector('.SvgWrapper-svg--dots');\nconst dotsFileInput:HTMLInputElement = document.querySelector('.FileInput--dots');\nconst dotsOptionsDiv:HTMLElement = document.querySelector('.Options--dots');\n\nconst dotsDownloadButton:HTMLAnchorElement = document.querySelector('.Button--dotsDownload');\n\nconst dotsOptions:IDotsOptions = {\n  minimumDotRadius: 1,\n  maximumDotRadius: 5,\n  distanceBetweenDots: 1,\n  resolution: 25,\n};\n\n// Inlines SVG data to download link\nfunction setDotsDownloadData() {\n  dotsDownloadButton.href = `data:application/octet-stream;base64,${ btoa(dotsSvgWrapperInner.innerHTML) }`;\n}\n\nfunction dotOptionsChangeHandler(name, value) {\n  // Update global options object\n  dotsOptions[name] = parseInt(value, 10);\n\n  // Redraw vertigo with new options\n  vertigo.setOptions(dotsOptions, setDotsDownloadData);\n}\n\nconst DOTS_OPTIONS_INPUTS = [\n  {\n    callback: dotOptionsChangeHandler,\n    label: 'Resolution',\n    max: 50,\n    min: 5,\n    name: 'resolution',\n    value: 25,\n  },\n  {\n    callback: dotOptionsChangeHandler,\n    label: 'Minimum dot radius',\n    max: 5,\n    min: 0,\n    name: 'minimumDotRadius',\n    value: 1,\n  },\n  {\n    callback: dotOptionsChangeHandler,\n    label: 'Maximum dot radius',\n    max: 20,\n    min: 1,\n    name: 'maximumDotRadius',\n    value: 5,\n  },\n  {\n    callback: dotOptionsChangeHandler,\n    label: 'Distance between dots',\n    max: 20,\n    min: 0,\n    name: 'distanceBetweenDots',\n    value: 2,\n  },\n];\n\nDOTS_OPTIONS_INPUTS.forEach(inputData => {\n  dotsOptionsDiv.appendChild(createOption(inputData));\n});\n\n\n// Create vertigo instance\nconst vertigo = new Vertigo(dotsOptions);\n\n// Show SVG\ndotsSvgWrapperInner.appendChild(vertigo.svg);\n\n// On file input change convert it\ndotsFileInput.addEventListener('change', () => {\n  const file:File = dotsFileInput.files[0];\n  const imageURL = URL.createObjectURL(file);\n\n  vertigo.convertImage(imageURL, setDotsDownloadData);\n});\n\n// On load draw hello image :)\nvertigo.convertImage(helloImage.getAttribute('src'), setDotsDownloadData);\n\n// -------------- SPIRAL\n\nconst spiralOptionsDiv:HTMLElement = document.querySelector('.Options--spiral');\nconst spiralDownloadButton:HTMLAnchorElement = document.querySelector('.Button--spiralDownload');\nconst spiralFileInput:HTMLInputElement = document.querySelector('.FileInput--spiral');\nconst spiralSvgWrapperInner:HTMLElement = document.querySelector('.SvgWrapper-svg--spiral');\n\nconst spiralOptions:ISpiralOptions = {\n  minimumLineWidth: 1,\n  maximumLineWidth: 5,\n  distanceBetweenLines: 1,\n  startingRadius: 5,\n};\n\n// Inlines SVG data to download link\nfunction setSpiralDownloadData() {\n  spiralDownloadButton.href = `data:application/octet-stream;base64,${ btoa(spiralSvgWrapperInner.innerHTML) }`;\n}\n\nfunction spiralOptionsChangeHandler(name, value) {\n  // Update global options object\n  spiralOptions[name] = parseInt(value, 10);\n\n  // Redraw vertigo with new options\n  spiral.setOptions(spiralOptions, setSpiralDownloadData);\n}\n\nconst SPIRAL_OPTIONS_INPUTS = [\n  {\n    callback: spiralOptionsChangeHandler,\n    label: 'Minimum line width',\n    min: 0,\n    max: 5,\n    name: 'minimumLineWidth',\n    value: 1,\n  },\n  {\n    callback: spiralOptionsChangeHandler,\n    label: 'Maximum line width',\n    min: 1,\n    max: 20,\n    name: 'maximumLineWidth',\n    value: 5,\n  },\n  {\n    callback: spiralOptionsChangeHandler,\n    label: 'Distance between lines',\n    min: 0,\n    max: 10,\n    name: 'distanceBetweenLines',\n    value: 1,\n  },\n  {\n    callback: spiralOptionsChangeHandler,\n    label: 'Starting radius',\n    min: 3,\n    max: 300,\n    name: 'startingRadius',\n    value: 5,\n  },\n]\n\nSPIRAL_OPTIONS_INPUTS.forEach(inputData => {\n  spiralOptionsDiv.appendChild(createOption(inputData));\n});\n\n\n// Create spiral instance\nconst spiral = new VertigoSpiral(spiralOptions);\n\n// Show SVG\nspiralSvgWrapperInner.appendChild(spiral.svg);\n\n// On file input change convert it\nspiralFileInput.addEventListener('change', () => {\n  const file:File = spiralFileInput.files[0];\n  const imageURL = URL.createObjectURL(file);\n\n  spiral.convertImage(imageURL, setSpiralDownloadData);\n});\n\nspiral.convertImage(helloImage.getAttribute('src'), setSpiralDownloadData);\n\n\n// --------- TEST IMAGES\n\nconst testImagesElements:NodeListOf<HTMLImageElement> = document.querySelectorAll('.TestImageButton');\n\n// Connect buttons to draw test images\n// IE can't forEach through NodeList\n// so we need to call Array.prototype.slice\nArray.prototype.slice.call(testImagesElements).forEach(button => {\n  button.addEventListener('click', e => {\n    const image = document.querySelector(e.target.getAttribute('data-image'));\n    const imageURL = image.getAttribute('src');\n    const type = e.target.getAttribute('data-type');\n\n    if (type === 'dots') {\n      vertigo.convertImage(imageURL, setDotsDownloadData);\n    } else {\n      spiral.convertImage(imageURL, setSpiralDownloadData);\n    }\n  });\n});\n"]}