{"version":3,"sources":["src/constants.ts","src/helpers.ts","src/convert-image-to-dots.ts","src/vertigo.ts","src/convert-image-to-spiral.ts","src/smooth-line.ts","src/spiral.ts","../src/FileSaver.js","src/demo-helpers.ts","src/generate-random-image.ts","src/demo.ts"],"names":[],"mappings":"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","file":"demo.91bcdece.js","sourceRoot":"..","sourcesContent":["// -- Global\n\nexport const DEBUG = false;\n\nexport const MAXIMUM_BRIGHTNESS = 255;\n\nexport interface IDot {\n  x: number;\n  y: number;\n}\n\n// -- Dots\n\n// How many dots are added with each concentric circle\nexport const DOT_INCREMENT_STEP:number = 6;\n\nexport interface IDotsOptions {\n  resolution: number;\n  minimumDotRadius: number;\n  maximumDotRadius: number;\n  distanceBetweenDots: number;\n  invert: boolean;\n};\n\nexport interface IDotsOptionsPartial {\n  resolution?: number;\n  minimumDotRadius?: number;\n  maximumDotRadius?: number;\n  distanceBetweenDots?: number;\n  invert?: boolean;\n};\n\nexport const dotsDefaultOptions:IDotsOptions = {\n  // Number of concentric circles\n  resolution: 25,\n  // Minimum dot radius\n  minimumDotRadius: 1,\n  // Maximum dot radius\n  maximumDotRadius: 5,\n  // Distance between dots\n  distanceBetweenDots: 2,\n  // By default, images are drawn as white on black\n  // disable this option to get black on white\n  invert: true,\n};\n\nexport type TDotsImage = number[][];\n\n// -- Spiral\n\nexport interface ISpiralOptions {\n  minimumLineWidth: number;\n  maximumLineWidth: number;\n  distanceBetweenLines: number;\n  startingRadius: number;\n  invert: boolean;\n};\n\nexport interface ISpiralOptionsPartial {\n  minimumLineWidth?: number;\n  maximumLineWidth?: number;\n  distanceBetweenLines?: number;\n  startingRadius?: number;\n  invert?: boolean;\n};\n\nexport const spiralDefaultOptions:ISpiralOptions = {\n  // Minimum line width\n  minimumLineWidth: 1,\n  // Maximum line width\n  maximumLineWidth: 5,\n  // Distance between lines\n  distanceBetweenLines: 1,\n  // Starting radius\n  startingRadius: 4,\n  // By default, images are drawn as white on black\n  // disable this option to get black on white\n  invert: true,\n};\n\n\n\nexport interface ISpiralSegment {\n  x: number;\n  y: number;\n  width: number;\n};\n\nexport type TSpiralImage = ISpiralSegment[];\n","export function toFixed(number:number, numberOfDecimalSpaces:number = 2):number {\n  return parseFloat(number.toFixed(numberOfDecimalSpaces));\n}\n\n\nexport function getRectBrightness(ctx:CanvasRenderingContext2D, x:number, y:number, rectWidth:number):number {\n  const imageData = ctx.getImageData(x, y, rectWidth, rectWidth);\n\n  let brightness = 0;\n\n  for (let k = 0; k < imageData.data.length; k += 4) {\n      const r = imageData.data[k];\n      const g = imageData.data[k + 1];\n      const b = imageData.data[k + 2];\n      const a = imageData.data[k + 3];\n\n      brightness += 0.299 * r + 0.587 * g + 0.114 * b;\n  }\n\n  const COLORS_COUNT = 4; // r g b a\n\n  return brightness / (imageData.data.length / COLORS_COUNT);\n}\n\nexport function createSvg(svgSize:number, moveToCenter:boolean, className:string):SVGElement {\n  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n  const min = moveToCenter ? svgSize / -2 : 0;\n\n  svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n  svg.setAttribute('class', className);\n  svg.setAttribute('viewBox', `${ min } ${ min } ${ svgSize } ${ svgSize }`);\n\n  return svg;\n}\n\n\nexport function mapRange(value:number, inputRange:number, outputMin:number, outputMax:number) {\n  const outputRange = outputMax - outputMin;\n  return value / inputRange * outputRange + outputMin;\n}\n\nexport function drawImageOnCanvas(\n  imageSrc:string,\n  size: 500,\n  callback:(canvas:HTMLCanvasElement) => void,\n) {\n  const canvas:HTMLCanvasElement = document.createElement('canvas');\n  canvas.width = size;\n  canvas.height = size;\n\n  const ctx:CanvasRenderingContext2D = canvas.getContext('2d');\n\n  const image = new Image();\n  image.addEventListener('load', () => {\n    // Get the largest square from the image\n    let yOffset = 0;\n    let xOffset = 0;\n    let imageSize;\n\n    if (image.height > image.width) {\n      yOffset = (image.height - image.width) / 2;\n      imageSize = image.width;\n    } else {\n      xOffset = (image.width - image.height) / 2;\n      imageSize = image.height;\n    }\n\n    ctx.drawImage(image, xOffset, yOffset, imageSize, imageSize, 0, 0, size, size);\n\n    callback(canvas);\n  });\n\n  // Load image\n  image.src = imageSrc;\n}\n","import {\n  drawImageOnCanvas,\n  getRectBrightness,\n  mapRange,\n  toFixed,\n} from './helpers';\nimport {\n  DEBUG,\n  DOT_INCREMENT_STEP,\n  dotsDefaultOptions,\n  IDotsOptions,\n  IDotsOptionsPartial,\n  MAXIMUM_BRIGHTNESS,\n  TDotsImage,\n} from './constants';\n\n\nfunction getDotSizeFromRect(brightness, minimumDotRadius, maximumDotRadius) {\n  const circleSize = mapRange(brightness, MAXIMUM_BRIGHTNESS, minimumDotRadius, maximumDotRadius);\n\n  return toFixed(circleSize, 2);\n}\n\nfunction getRectCornerFromCenter(r, angle, rectangleSize, size) {\n  const rectCenterX = r * Math.cos(angle);\n  const rectCenterY = r * Math.sin(angle);\n\n  const x = rectCenterX - (rectangleSize / 2) + (size / 2);\n  const y = rectCenterY - (rectangleSize / 2) + (size / 2);\n\n  return {\n    x,\n    y,\n  };\n}\n\n// TODO low res\n// if (brightness < 100) {\n//   convertedImage[i][j] = 1;\n// } else if (brightness < 200) {\n//   convertedImage[i][j] = 2;\n// } else {\n//   convertedImage[i][j] = 4;\n// }\n\nexport default function convertImageToDots(\n  imageSrc:string,\n  customOptions:IDotsOptionsPartial,\n  callback:(convertedImage:TDotsImage) => void\n) {\n  const size = 500;\n\n  const options:IDotsOptions = {\n    ...dotsDefaultOptions,\n    ...customOptions,\n  };\n\n  drawImageOnCanvas(imageSrc, size, (canvas) => {\n    const ctx:CanvasRenderingContext2D = canvas.getContext('2d');\n\n    const convertedImage:TDotsImage = [[]];\n    const rectangleSize = size / 2 / (options.resolution + 0.5);\n\n    const helperRectangles = [];\n\n    // Center dot\n    const { x, y } = getRectCornerFromCenter(0, 0, rectangleSize, size);\n    let brightness = getRectBrightness(ctx, x, y, rectangleSize);\n\n    if (!options.invert) {\n      brightness = 255 - brightness;\n    }\n\n    convertedImage[0][0] = getDotSizeFromRect(brightness, options.minimumDotRadius, options.maximumDotRadius);\n\n    if (DEBUG) {\n      helperRectangles.push({ x, y })\n    }\n\n    for (let i = 1; i <= options.resolution; i++) {\n      const r = i * rectangleSize;\n\n      const dotCount = i * DOT_INCREMENT_STEP;\n      const dotAngleStep = 360 / dotCount;\n\n      convertedImage[i] = [];\n\n      for (let j = 0; j < dotCount; j++) {\n        const angle = Math.PI * (dotAngleStep * j) / 180;\n\n        const { x, y } = getRectCornerFromCenter(r, angle, rectangleSize, size);\n\n        let brightness = getRectBrightness(ctx, x, y, rectangleSize);\n\n        if (!options.invert) {\n          brightness = 255 - brightness;\n        }\n\n        convertedImage[i][j] = getDotSizeFromRect(brightness, options.minimumDotRadius, options.maximumDotRadius);\n\n        if (DEBUG) {\n          helperRectangles.push({ x, y });\n        }\n      }\n    }\n\n    callback(convertedImage);\n\n    if (DEBUG) {\n      ctx.strokeStyle = 'orange';\n\n      helperRectangles.forEach(rect => {\n        ctx.strokeRect(rect.x, rect.y, rectangleSize, rectangleSize);\n      });\n\n      document.querySelector('.Debug--dots').innerHTML = '';\n      document.querySelector('.Debug--dots').appendChild(canvas);\n    }\n  });\n}\n","import {\n  DOT_INCREMENT_STEP,\n  IDotsOptions,\n  IDotsOptionsPartial,\n  dotsDefaultOptions,\n  TDotsImage,\n} from './constants';\n\nimport { createSvg } from './helpers';\nimport convertImageToDots from './convert-image-to-dots';\n\n// TODO\n//\n// * Dynamic dot size\n// * Performance?\n\ninterface IDot {\n  element: SVGCircleElement;\n  x: string;\n  y: string;\n  scale: number;\n};\n\ntype TConvertCallback = (convertedImage:TDotsImage) => void;\n\nexport default class Vertigo {\n  private options:IDotsOptions;\n  private dots:IDot[][];\n  private radiusGrowStep:number;\n  private imageURL:string;\n\n  public svg:SVGElement;\n\n  constructor(options?:IDotsOptionsPartial) {\n    this.options = {\n      ...dotsDefaultOptions,\n      ...options,\n    };\n\n    this.radiusGrowStep = this.options.maximumDotRadius * 2 + this.options.distanceBetweenDots;\n\n    const size = this.options.resolution * 2 * this.radiusGrowStep;\n    const svgSize = size + this.options.maximumDotRadius * 2;\n\n    this.svg = createSvg(svgSize, true, 'Vertigo');\n\n    this.generateDots();\n  }\n\n  private static createDot(x:string, y:string, dotRadius:number, className = 'Dots-dot'):IDot {\n    const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n    dot.setAttribute('class', className);\n    dot.setAttribute('cx', x);\n    dot.setAttribute('cy', y);\n    dot.setAttribute('r', dotRadius.toString());\n\n    return {\n      element: dot,\n      x,\n      y,\n      scale: 1,\n    };\n  }\n\n  private generateDots() {\n    // Create central dot\n    const centralDot = Vertigo.createDot('0', '0', this.options.minimumDotRadius);\n\n    this.dots = [\n      [centralDot],\n    ];\n\n    this.svg.appendChild(centralDot.element);\n\n    for (let i = 1; i <= this.options.resolution; i++) {\n      const r = i * this.radiusGrowStep;\n\n      const dotCount = i * DOT_INCREMENT_STEP;\n      const dotAngleStep = 360 / dotCount;\n\n      this.dots[i] = [];\n\n      for (let j = 0; j < dotCount; j++) {\n        const angle = Math.PI * (dotAngleStep * j) / 180;\n\n        const x = (r * Math.cos(angle)).toFixed(3);\n        const y = (r * Math.sin(angle)).toFixed(3);\n\n        const dot = Vertigo.createDot(x, y, this.options.minimumDotRadius);\n\n        this.dots[i].push(dot);\n\n        this.svg.appendChild(dot.element);\n      }\n    }\n  }\n\n  public drawImage(image:TDotsImage) {\n    // Remove saved image file because we are drawing a custom image\n    this.imageURL = null;\n\n    image.forEach((dots:number[], i:number) => {\n      dots.forEach((dotScale:number, j:number) => {\n        const circle = this.dots[i];\n\n        if (circle) {\n          const dot = circle[j];\n\n          if (dot.scale !== dotScale) {\n            dot.scale = dotScale;\n\n            dot.element.setAttribute('r', dotScale.toString());\n          }\n        }\n      });\n    });\n  }\n\n  public convertImage(imageURL, callback?:TConvertCallback) {\n    convertImageToDots(imageURL, this.options, (convertedImage:TDotsImage) => {\n      this.drawImage(convertedImage);\n      this.imageURL = imageURL;\n\n      if (callback) {\n        callback(convertedImage);\n      }\n    });\n  }\n\n  private removeDots() {\n    this.dots.forEach(circle => {\n      circle.forEach(dot => {\n        dot.element.parentNode.removeChild(dot.element);\n      });\n    });\n  }\n\n  public setOptions(newOptions:IDotsOptionsPartial, callback?:TConvertCallback) {\n    this.options = {\n      ...this.options,\n      ...newOptions,\n    };\n\n    this.radiusGrowStep = this.options.maximumDotRadius * 2 + this.options.distanceBetweenDots;\n\n    const size = this.options.resolution * 2 * this.radiusGrowStep;\n    const svgSize = size + this.options.maximumDotRadius * 2;\n\n    // Update svg size\n    this.svg.setAttribute('viewBox', `${ svgSize / -2 } ${ svgSize / -2 } ${ svgSize } ${ svgSize }`);\n\n    this.removeDots();\n    this.generateDots();\n\n    if (this.imageURL) {\n      this.convertImage(this.imageURL, callback);\n    }\n  }\n\n  public getOptions() {\n    return { ...this.options }\n  }\n}\n","import {\n  drawImageOnCanvas,\n  getRectBrightness,\n  mapRange,\n  toFixed,\n} from './helpers';\nimport {\n  DEBUG,\n  ISpiralOptions,\n  ISpiralOptionsPartial,\n  MAXIMUM_BRIGHTNESS,\n  spiralDefaultOptions,\n  TSpiralImage,\n} from './constants';\n\n\nexport default function convertImageToSpiral(\n  imageSrc:string,\n  customOptions:ISpiralOptionsPartial,\n  callback:(convertedImage:TSpiralImage) => void\n) {\n  const size = 500;\n\n  const options:ISpiralOptions = {\n    ...spiralDefaultOptions,\n    ...customOptions,\n  };\n\n  drawImageOnCanvas(imageSrc, size, (canvas) => {\n    const ctx:CanvasRenderingContext2D = canvas.getContext('2d');\n    const helperRectangles = [];\n    const convertedImage:TSpiralImage = [];\n\n    const center = size / 2;\n\n    // Experiment with the size of the rectangle\n    const rectangleSize = Math.round((options.distanceBetweenLines + options.maximumLineWidth) * 0.8);\n\n    const distance = (options.distanceBetweenLines + options.maximumLineWidth) / (2 * Math.PI);\n\n    // Size of the image, minus the width of the starting circle\n    // divided by the distance between lines\n    const maxHalfRotationsCount = Math.floor((size - (options.startingRadius * 2)) / (options.distanceBetweenLines + options.maximumLineWidth));\n\n    // Maximum spiral angle\n    const maxAngle = maxHalfRotationsCount * Math.PI; // size / 2.1 / distance; // In radians\n\n    let angleIncrementStep = 3 / options.startingRadius;\n\n    for (let angle = 0; angle < maxAngle; angle += angleIncrementStep) {\n      const r = options.startingRadius + distance * angle;\n      const x = toFixed(center + r * Math.cos(angle), 3);\n      const y = toFixed(center + r * Math.sin(angle), 3);\n\n      helperRectangles.push({ x, y });\n\n      let brightness = getRectBrightness(ctx, x, y, rectangleSize);\n\n      if (!options.invert) {\n        brightness = 255 - brightness;\n      }\n\n      const width = mapRange(brightness, MAXIMUM_BRIGHTNESS, options.minimumLineWidth, options.maximumLineWidth);\n\n      angleIncrementStep = 3 / r;\n\n      convertedImage.push({\n        x,\n        y,\n        width,\n      });\n    }\n\n    callback(convertedImage);\n\n    if (DEBUG) {\n      ctx.strokeStyle = 'orange';\n\n      helperRectangles.forEach(rect => {\n        ctx.strokeRect(rect.x, rect.y, rectangleSize, rectangleSize);\n      });\n\n      document.querySelector('.Debug--spiral').innerHTML = '';\n      document.querySelector('.Debug--spiral').appendChild(canvas);\n    }\n  });\n}\n\n\n\n\n\n\n","// The smoothing ratio\nconst smoothing = 0.2\n\n// Properties of a line\n// I:  - pointA (array) [x,y]: coordinates\n//     - pointB (array) [x,y]: coordinates\n// O:  - (object) { length: l, angle: a }: properties of the line\nconst lineProperties = (pointA, pointB) => {\n  const lengthX = pointB.x - pointA.x\n  const lengthY = pointB.y - pointA.y\n\n  return {\n    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\n    angle: Math.atan2(lengthY, lengthX)\n  }\n}\n\n// Position of a control point\n// I:  - current (array) [x, y]: current point coordinates\n//     - previous (array) [x, y]: previous point coordinates\n//     - next (array) [x, y]: next point coordinates\n//     - reverse (boolean, optional): sets the direction\n// O:  - (array) [x,y]: a tuple of coordinates\nconst controlPoint = (current, previous, next, reverse = false) => {\n\n  // When 'current' is the first or last point of the array\n  // 'previous' or 'next' don't exist.\n  // Replace with 'current'\n  const p = previous || current;\n  const n = next || current;\n\n  // Properties of the opposed-line\n  const o = lineProperties(p, n);\n\n  // If is end-control-point, add PI to the angle to go backward\n  const angle = o.angle + (reverse ? Math.PI : 0);\n  const length = o.length * smoothing;\n\n  // The control point position is relative to the current point\n  const x = current.x + Math.cos(angle) * length;\n  const y = current.y + Math.sin(angle) * length;\n  return { x, y }\n}\n\n// Create the bezier curve command\n// I:  - point (array) [x,y]: current point coordinates\n//     - i (integer): index of 'point' in the array 'a'\n//     - a (array): complete array of points coordinates\n// O:  - (string) 'C x2,y2 x1,y1 x,y': SVG cubic bezier C command\nconst bezierCommand = (point, i, a) => {\n  // start control point\n  const cps = controlPoint(a[i - 1], a[i - 2], point);\n\n  // end control point\n  const cpe = controlPoint(point, a[i - 1], a[i + 1], true);\n\n  return `C ${cps.x},${cps.y} ${cpe.x},${cpe.y} ${point.x},${point.y}`\n}\n\n\nexport default function smoothLine(points, shouldClose = true) {\n  // build the d attributes by looping over the points\n  const d = points.reduce((acc, point, i, a) => {\n    if (i === 0) {\n      return `M ${point.x},${point.y}`;\n    }\n\n    return `${acc} ${bezierCommand(point, i, a)}`;\n  }, \"\");\n\n  if (shouldClose) {\n    return `${ d } Z`\n  } else {\n    return d;\n  }\n}\n","import {\n  IDot,\n  ISpiralOptions,\n  ISpiralOptionsPartial,\n  spiralDefaultOptions,\n  TSpiralImage,\n} from \"./constants\";\nimport {\n  createSvg,\n  toFixed,\n} from './helpers';\n\nimport convertImageToSpiral from './convert-image-to-spiral'\nimport smoothLine from \"./smooth-line\";\n\ntype TSpiralConvertCallback = (convertedImage: TSpiralImage) => void;\n\n\nconst SVG_SIZE = 500;\n\nexport default class VertigoSpiral {\n  private options: ISpiralOptions;\n  private imageURL: string;\n  private svgPath: SVGPathElement;\n\n  public svg: SVGElement;\n\n  constructor(options?: ISpiralOptionsPartial) {\n    this.options = {\n      ...spiralDefaultOptions,\n      ...options,\n    };\n\n    this.svg = createSvg(SVG_SIZE, false, 'Spiral');\n\n    this.svgPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n    this.svgPath.setAttribute('class', 'Spiral-path');\n\n    this.svg.appendChild(this.svgPath);\n  }\n\n  public convertImage(imageURL, callback?: TSpiralConvertCallback) {\n    convertImageToSpiral(imageURL, this.options, (convertedImage: TSpiralImage) => {\n      this.drawImage(convertedImage);\n      this.imageURL = imageURL;\n\n      if (callback) {\n        callback(convertedImage);\n      }\n    });\n  }\n\n  // Takes three dots and returns two dots,\n  // a vector which direction is half angle between these three dots\n  // and velocity is equal to a spiral line's width at that dot\n  /*\n                          • outerDots[0]\n                         /\n                        /\n    previousDot •------• dot\n                      / \\\n                     /   • nextDot\n       outerDots[1] •\n  */\n  private static getOuterDots(previousDot, dot, nextDot) {\n    // Angle between (previosDot, dot) vector and x axis\n    /*\n    previousDot •------• dot\n               angle1 / \\\n                     /   • nextDot\n    */\n    let angle1 = VertigoSpiral.getAngleBetweenThreeDots(previousDot, dot, nextDot) / 2;\n\n    let offset = 100;\n\n    if (angle1 > 0) {\n      offset = -100;\n    }\n    // Angle between (previosDot, dot) vector and x axis\n    /*\n                 dot •--------• (dot.x + offset, dot.y)\n                    / angle2\n                   /\n      previousDot •\n    */\n    const angle2 = VertigoSpiral.getAngleBetweenThreeDots(previousDot, dot, {\n      x: dot.x + offset, // Moving dot on x axis\n      y: dot.y,\n    });\n\n    // Angle between the x axis and the half angle vector\n    const angle = toFixed(angle2 - angle1, 2);\n\n    const halfWidth = dot.width / 2;\n\n    const point1 = {\n      x: toFixed(dot.x + halfWidth * Math.cos(angle), 2),\n      y: toFixed(dot.y - halfWidth * Math.sin(angle), 2),\n    };\n\n    const point2 = {\n      x: toFixed(dot.x + halfWidth * Math.cos(angle + Math.PI), 2),\n      y: toFixed(dot.y - halfWidth * Math.sin(angle + Math.PI), 2),\n    };\n\n    const outerDots = [\n      point1,\n      point2,\n    ];\n\n    return outerDots;\n  }\n\n  private static getVector(a, b) {\n    return {\n      x: (a.x - b.x),\n      y: (a.y - b.y),\n    };\n  }\n\n  private static getAngleBetweenThreeDots(a, b, c) {\n    const vectorBA = VertigoSpiral.getVector(b, a);\n    const vectorBC = VertigoSpiral.getVector(b, c);\n\n    const angle = Math.atan2(vectorBC.y, vectorBC.x) - Math.atan2(vectorBA.y, vectorBA.x);\n\n    return angle;\n  }\n\n  public drawImage(image) {\n    // Setting starting dot, based on \"startingRadius\"\n    // Spiral always starts from PI angle, that's why it's moved to the \"right\"\n    // (in other words, adding \"r\" to the \"x\" axis coordinate)\n    // while keeping y coordinate centered\n    const pathOuter = [];\n    const pathInner = [];\n\n    // We need three dots to draw a bezier,\n    // that's why loop starts from 1 and ends on length - 1\n    for (let i = 1; i < image.length - 1; i++) {\n      const previousDot = image[i - 1];\n      const currentDot = image[i];\n      const nextDot = image[i + 1];\n\n      const od = VertigoSpiral.getOuterDots(previousDot, currentDot, nextDot);\n\n      pathOuter.push(od[0]);\n      pathInner.push(od[1]);\n    }\n\n    const pathPoints = [\n      ...pathOuter,\n      ...pathInner.reverse(),\n    ];\n\n    this.svgPath.setAttribute('d', smoothLine(pathPoints));\n  }\n\n  public setOptions(newOptions:ISpiralOptionsPartial, callback?:TSpiralConvertCallback) {\n    this.options = {\n      ...this.options,\n      ...newOptions,\n    };\n\n    if (this.imageURL) {\n      this.convertImage(this.imageURL, callback);\n    }\n  }\n\n  public getOptions() {\n    return { ...this.options }\n  }\n}\n","/*\n* FileSaver.js\n* A saveAs() FileSaver implementation.\n*\n* By Eli Grey, http://eligrey.com\n*\n* License : https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md (MIT)\n* source  : http://purl.eligrey.com/github/FileSaver.js\n*/\n\n// The one and only way of getting global scope in all environments\n// https://stackoverflow.com/q/3277182/1008999\nvar _global = typeof window === 'object' && window.window === window\n  ? window : typeof self === 'object' && self.self === self\n  ? self : typeof global === 'object' && global.global === global\n  ? global\n  : this\n\nfunction bom (blob, opts) {\n  if (typeof opts === 'undefined') opts = { autoBom: false }\n  else if (typeof opts !== 'object') {\n    console.warn('Deprecated: Expected third argument to be a object')\n    opts = { autoBom: !opts }\n  }\n\n  // prepend BOM for UTF-8 XML and text/* types (including HTML)\n  // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF\n  if (opts.autoBom && /^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(blob.type)) {\n    return new Blob([String.fromCharCode(0xFEFF), blob], { type: blob.type })\n  }\n  return blob\n}\n\nfunction download (url, name, opts) {\n  var xhr = new XMLHttpRequest()\n  xhr.open('GET', url)\n  xhr.responseType = 'blob'\n  xhr.onload = function () {\n    saveAs(xhr.response, name, opts)\n  }\n  xhr.onerror = function () {\n    console.error('could not download file')\n  }\n  xhr.send()\n}\n\nfunction corsEnabled (url) {\n  var xhr = new XMLHttpRequest()\n  // use sync to avoid popup blocker\n  xhr.open('HEAD', url, false)\n  try {\n    xhr.send()\n  } catch (e) {}\n  return xhr.status >= 200 && xhr.status <= 299\n}\n\n// `a.click()` doesn't work for all browsers (#465)\nfunction click (node) {\n  try {\n    node.dispatchEvent(new MouseEvent('click'))\n  } catch (e) {\n    var evt = document.createEvent('MouseEvents')\n    evt.initMouseEvent('click', true, true, window, 0, 0, 0, 80,\n                          20, false, false, false, false, 0, null)\n    node.dispatchEvent(evt)\n  }\n}\n\nvar saveAs = _global.saveAs || (\n  // probably in some web worker\n  (typeof window !== 'object' || window !== _global)\n    ? function saveAs () { /* noop */ }\n\n  // Use download attribute first if possible (#193 Lumia mobile)\n  : 'download' in HTMLAnchorElement.prototype\n  ? function saveAs (blob, name, opts) {\n    var URL = _global.URL || _global.webkitURL\n    var a = document.createElement('a')\n    name = name || blob.name || 'download'\n\n    a.download = name\n    a.rel = 'noopener' // tabnabbing\n\n    // TODO: detect chrome extensions & packaged apps\n    // a.target = '_blank'\n\n    if (typeof blob === 'string') {\n      // Support regular links\n      a.href = blob\n      if (a.origin !== location.origin) {\n        corsEnabled(a.href)\n          ? download(blob, name, opts)\n          : click(a, a.target = '_blank')\n      } else {\n        click(a)\n      }\n    } else {\n      // Support blobs\n      a.href = URL.createObjectURL(blob)\n      setTimeout(function () { URL.revokeObjectURL(a.href) }, 4E4) // 40s\n      setTimeout(function () { click(a) }, 0)\n    }\n  }\n\n  // Use msSaveOrOpenBlob as a second approach\n  : 'msSaveOrOpenBlob' in navigator\n  ? function saveAs (blob, name, opts) {\n    name = name || blob.name || 'download'\n\n    if (typeof blob === 'string') {\n      if (corsEnabled(blob)) {\n        download(blob, name, opts)\n      } else {\n        var a = document.createElement('a')\n        a.href = blob\n        a.target = '_blank'\n        setTimeout(function () { click(a) })\n      }\n    } else {\n      navigator.msSaveOrOpenBlob(bom(blob, opts), name)\n    }\n  }\n\n  // Fallback to using FileReader and a popup\n  : function saveAs (blob, name, opts, popup) {\n    // Open a popup immediately do go around popup blocker\n    // Mostly only available on user interaction and the fileReader is async so...\n    popup = popup || open('', '_blank')\n    if (popup) {\n      popup.document.title =\n      popup.document.body.innerText = 'downloading...'\n    }\n\n    if (typeof blob === 'string') return download(blob, name, opts)\n\n    var force = blob.type === 'application/octet-stream'\n    var isSafari = /constructor/i.test(_global.HTMLElement) || _global.safari\n    var isChromeIOS = /CriOS\\/[\\d]+/.test(navigator.userAgent)\n\n    if ((isChromeIOS || (force && isSafari)) && typeof FileReader === 'object') {\n      // Safari doesn't allow downloading of blob URLs\n      var reader = new FileReader()\n      reader.onloadend = function () {\n        var url = reader.result\n        url = isChromeIOS ? url : url.replace(/^data:[^;]*;/, 'data:attachment/file;')\n        if (popup) popup.location.href = url\n        else location = url\n        popup = null // reverse-tabnabbing #460\n      }\n      reader.readAsDataURL(blob)\n    } else {\n      var URL = _global.URL || _global.webkitURL\n      var url = URL.createObjectURL(blob)\n      if (popup) popup.location = url\n      else location.href = url\n      popup = null // reverse-tabnabbing #460\n      setTimeout(function () { URL.revokeObjectURL(url) }, 4E4) // 40s\n    }\n  }\n)\n\n_global.saveAs = saveAs.saveAs = saveAs\n\nif (typeof module !== 'undefined') {\n  module.exports = saveAs;\n}\n","import { saveAs } from 'file-saver';\n\nexport function createOption({\n  callback,\n  label,\n  max,\n  min,\n  name,\n  step = '1',\n  value,\n}) {\n  const spanRange = document.createElement('span');\n  spanRange.innerHTML = `(${ min } - ${ max })`;\n\n  const labelName = document.createElement('label');\n  labelName.innerHTML = `${ label }: `;\n  labelName.appendChild(spanRange);\n\n  const spanValue = document.createElement('span');\n  spanValue.innerHTML = ` ${ value }`;\n\n  const input = document.createElement('input');\n  input.setAttribute('type', 'range');\n  input.setAttribute('min', min);\n  input.setAttribute('max', max);\n  input.setAttribute('value', value);\n  input.setAttribute('step', step);\n  input.setAttribute('class', `OptionsInput OptionsInput--${ name }`);\n  input.addEventListener('change', e => {\n    callback(name, e.target.value);\n    spanValue.innerHTML = ` ${ e.target.value }`;\n  });\n\n  const divOption = document.createElement('div');\n  divOption.appendChild(labelName);\n  divOption.appendChild(input);\n  divOption.appendChild(spanValue);\n\n  return divOption;\n}\n\nexport function createCheckboxOption({\n  callback,\n  label,\n  name,\n  value,\n}) {\n  const labelName = document.createElement('label');\n  labelName.innerHTML = ` ${ label }`;\n\n  const input = document.createElement('input');\n  input.setAttribute('type', 'checkbox');\n  input.setAttribute('checked', value);\n  input.setAttribute('class', `OptionsInput OptionsInput--${ name }`);\n  input.addEventListener('change', e => {\n    callback(name, e.target.checked);\n  });\n\n  labelName.prepend(input);\n\n  const divOption = document.createElement('div');\n  divOption.appendChild(labelName);\n\n\n  return divOption;\n}\n\nconst namingMap = {\n  distanceBetweenDots: 'dist',\n  distanceBetweenLines: 'dist',\n  startingRadius: 'start',\n};\n\nexport function downloadSVG (instance, type) {\n  const options = instance.getOptions();\n\n  console.log(instance.imageURL)\n\n  let name = type;\n\n  Object.keys(options).forEach(key => {\n    const shortOptionName = namingMap[key] || key.substr(0, 3);\n    name += `_${ shortOptionName }-${ options[key] }`;\n  });\n\n  name += '.svg';\n\n  saveAs(`data:application/octet-stream;base64,${ btoa(instance.svg.outerHTML) }`, name);\n}\n","import { toFixed } from './helpers';\n\nfunction getRandomScale() {\n  const random:number = Math.random() * 3 + 1;\n\n  return toFixed(random, 2);\n}\n\nfunction generateRandomImage(resolution:number) {\n  const image = [\n    // Center dot\n    [getRandomScale()],\n  ];\n\n  const dotStep:number = 6;\n\n  for (let i:number = 1; i <= resolution; i++) {\n    const dotCount:number = i * dotStep;\n    image[i] = [];\n\n    for (let j = 0; j < dotCount; j++) {\n      image[i].push(getRandomScale())\n    }\n  }\n\n  return image;\n}\n\nexport default generateRandomImage;\n","import Vertigo from './vertigo';\nimport VertigoSpiral from './spiral';\nimport {\n  ISpiralOptions,\n  IDotsOptions,\n} from './constants';\nimport { createOption, createCheckboxOption, downloadSVG } from './demo-helpers';\nimport generateRandomImage from './generate-random-image';\n\nconst helloImage:HTMLElement = document.querySelector('.TestImage--hello');\n\n// ------- DOTS\n\nconst dotsSvgWrapperInner:HTMLElement = document.querySelector('.SvgWrapper-inner--dots');\nconst dotsSvgWrapper:HTMLElement = document.querySelector('.SvgWrapper-svg--dots');\nconst dotsFileInput:HTMLInputElement = document.querySelector('.FileInput--dots');\nconst dotsOptionsDiv:HTMLElement = document.querySelector('.Options--dots');\n\n\nconst dotsDownloadButton:HTMLAnchorElement = document.querySelector('.Button--dotsDownload');\nconst dotsRandomButton:HTMLButtonElement = document.querySelector('.Button--dotsRandom');\n\nconst dotsOptions:IDotsOptions = {\n  minimumDotRadius: 1,\n  maximumDotRadius: 5,\n  distanceBetweenDots: 1,\n  resolution: 25,\n  invert: true,\n};\n\nfunction dotOptionsChangeHandler(name, value) {\n  // Update global options object\n  dotsOptions[name] = parseInt(value, 10);\n\n  if (name === 'invert') {\n    dotsOptions[name] = Boolean(value);\n\n    if (dotsOptions[name]) {\n      dotsSvgWrapperInner.classList.add('SvgWrapper-inner--invert');\n    } else {\n      dotsSvgWrapperInner.classList.remove('SvgWrapper-inner--invert');\n    }\n  }\n\n  // Redraw vertigo with new options\n  vertigo.setOptions(dotsOptions);\n}\n\nconst DOTS_OPTIONS_INPUTS = [\n  {\n    callback: dotOptionsChangeHandler,\n    label: 'Resolution',\n    max: 50,\n    min: 5,\n    name: 'resolution',\n    value: 25,\n  },\n  {\n    callback: dotOptionsChangeHandler,\n    label: 'Minimum dot radius',\n    max: 5,\n    min: 0,\n    name: 'minimumDotRadius',\n    value: 1,\n  },\n  {\n    callback: dotOptionsChangeHandler,\n    label: 'Maximum dot radius',\n    max: 20,\n    min: 1,\n    name: 'maximumDotRadius',\n    value: 5,\n  },\n  {\n    callback: dotOptionsChangeHandler,\n    label: 'Distance between dots',\n    max: 20,\n    min: 0,\n    name: 'distanceBetweenDots',\n    value: 1,\n  },\n];\n\nconst DOTS_INVERT_INPUT = {\n  callback: dotOptionsChangeHandler,\n  label: 'Invert colors',\n  name: 'invert',\n  value: true,\n};\n\nDOTS_OPTIONS_INPUTS.forEach(inputData => {\n  dotsOptionsDiv.appendChild(createOption(inputData));\n});\n\ndotsOptionsDiv.appendChild(createCheckboxOption(DOTS_INVERT_INPUT));\n\n\n// Create vertigo instance\nconst vertigo = new Vertigo(dotsOptions);\n\n// Show SVG\ndotsSvgWrapper.appendChild(vertigo.svg);\n\n// On file input change convert it\ndotsFileInput.addEventListener('change', () => {\n  const file:File = dotsFileInput.files[0];\n  const imageURL = URL.createObjectURL(file);\n\n  vertigo.convertImage(imageURL);\n});\n\n// Download SVG\ndotsDownloadButton.addEventListener('click', () => downloadSVG(vertigo, 'vertigo'));\n\n// Draw random image\ndotsRandomButton.addEventListener('click', () => {\n  vertigo.drawImage(generateRandomImage(vertigo.getOptions().resolution));\n})\n\n// On load draw hello image :)\nvertigo.convertImage(helloImage.getAttribute('src'));\n\n// -------------- SPIRAL\n\nconst spiralOptionsDiv:HTMLElement = document.querySelector('.Options--spiral');\nconst spiralDownloadButton:HTMLAnchorElement = document.querySelector('.Button--spiralDownload');\nconst spiralFileInput:HTMLInputElement = document.querySelector('.FileInput--spiral');\nconst spiralSvgWrapper:HTMLElement = document.querySelector('.SvgWrapper-svg--spiral');\nconst spiralSvgWrapperInner:HTMLElement = document.querySelector('.SvgWrapper-inner--spiral');\n\nconst spiralOptions:ISpiralOptions = {\n  minimumLineWidth: 1,\n  maximumLineWidth: 5,\n  distanceBetweenLines: 1,\n  startingRadius: 3,\n  invert: true,\n};\n\nfunction spiralOptionsChangeHandler(name, value) {\n  // Update global options object\n  spiralOptions[name] = parseInt(value, 10);\n\n  if (name === 'invert') {\n    spiralOptions[name] = Boolean(value);\n\n    if (spiralOptions[name]) {\n      spiralSvgWrapperInner.classList.add('SvgWrapper-inner--invert');\n    } else {\n      spiralSvgWrapperInner.classList.remove('SvgWrapper-inner--invert');\n    }\n  }\n\n  // Redraw vertigo with new options\n  spiral.setOptions(spiralOptions);\n}\n\nconst SPIRAL_OPTIONS_INPUTS = [\n  {\n    callback: spiralOptionsChangeHandler,\n    label: 'Minimum line width',\n    min: 0,\n    max: 5,\n    name: 'minimumLineWidth',\n    value: 1,\n  },\n  {\n    callback: spiralOptionsChangeHandler,\n    label: 'Maximum line width',\n    min: 1,\n    max: 20,\n    name: 'maximumLineWidth',\n    value: 5,\n  },\n  {\n    callback: spiralOptionsChangeHandler,\n    label: 'Distance between lines',\n    min: 0,\n    max: 10,\n    name: 'distanceBetweenLines',\n    value: 1,\n  },\n  {\n    callback: spiralOptionsChangeHandler,\n    label: 'Starting radius',\n    min: 3,\n    max: 300,\n    name: 'startingRadius',\n    value: 3,\n  },\n];\n\nconst SPIRAL_INVERT_INPUT = {\n  callback: spiralOptionsChangeHandler,\n  label: 'Invert colors',\n  name: 'invert',\n  value: true,\n};\n\n\nSPIRAL_OPTIONS_INPUTS.forEach(inputData => {\n  spiralOptionsDiv.appendChild(createOption(inputData));\n});\n\nspiralOptionsDiv.appendChild(createCheckboxOption(SPIRAL_INVERT_INPUT));\n\n// Create spiral instance\nconst spiral = new VertigoSpiral(spiralOptions);\n\n// Show SVG\nspiralSvgWrapper.appendChild(spiral.svg);\n\n// On file input change convert it\nspiralFileInput.addEventListener('change', () => {\n  const file:File = spiralFileInput.files[0];\n  const imageURL = URL.createObjectURL(file);\n\n  spiral.convertImage(imageURL);\n});\n\n// Download SVG\nspiralDownloadButton.addEventListener('click', () => downloadSVG(spiral, 'spiral'));\n\n// Convert hello image on load\nspiral.convertImage(helloImage.getAttribute('src'));\n\n\n// --------- TEST IMAGES\n\nconst testImagesElements:NodeListOf<HTMLImageElement> = document.querySelectorAll('.TestImageButton');\n\n// Connect buttons to draw test images\n// IE can't forEach through NodeList\n// so we need to call Array.prototype.slice\nArray.prototype.slice.call(testImagesElements).forEach(button => {\n  button.addEventListener('click', e => {\n    const image = document.querySelector(e.target.getAttribute('data-image'));\n    const imageURL = image.getAttribute('src');\n    const type = e.target.getAttribute('data-type');\n\n    if (type === 'dots') {\n      vertigo.convertImage(imageURL);\n    } else {\n      spiral.convertImage(imageURL);\n    }\n  });\n});\n"]}